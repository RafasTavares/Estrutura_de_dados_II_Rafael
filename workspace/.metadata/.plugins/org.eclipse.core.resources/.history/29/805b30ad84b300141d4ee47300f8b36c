package Tree;

public class TrinaryTree {
	Node root;

	// Constructor
	public TrinaryTree() {
		root = null;
	}

	// Method to insert a value to Trinary Tree
	public void insert(int value) {
		root = insert(root, value);
	}

	// Method to create a new node with the given value and insert it to the
	// Trinary Tree
	private Node insert(Node root, int value) {
		if (root == null) {
			root = new Node(value);
			root.setLeft(null);
			root.setRight(null);
			root.setCenter(null);
		} else {
			if (value < root.getData()) {
				root.setLeft(insert(root.getLeft(), value));
			}
			if (value == root.getData()) {
				root.setCenter(insert(root.getCenter(), value));
			}
			if (value > root.getData()) {
				root.setRight(insert(root.getRight(), value));
			}
		}
		return root;
	}

	// Delete a value from the Trinary Tree
	public void delete(int value) {
		System.out.println("Delete " + value + " from the Tree...");
		root = delete(root, value);
	}

	// Method to delete the node with a give value from the Trinary Tree
	private Node delete(Node root, int value) {
		if (isPresent(root, value)) {
			if (root == null) {
				return root;
			}
			if (value < root.getData()) {
				root.setLeft(delete(root.getLeft(), value));
			} else if (value > root.getData()) {
				root.setRight(delete(root.getRight(), value));
			} else { // found element to delete
				if (root.getLeft() == null && root.getCenter() == null
						&& root.getRight() == null) {
					root = null;
					return root;
				}
				if (root.center != null) {
					root.setCenter(delete(root.getCenter(), value));
				} else {
					if (root.getLeft() != null && root.getRight() != null) {
						// Find Largest element in left subtree
						// replace current Node's data with the Largest Left
						// subtree data
						Node temp = findMax(root.getLeft());
						root.setData(temp.getData());
						root.setLeft(delete(root.getLeft(), temp.getData()));
						;
					} else if (root.getLeft() == null) {
						root = root.getRight();
						return root;
					} else if (root.getRight() == null) {
						root = root.getLeft();
						return root;
					}
				}
			}
		} else {
			System.out.println(value + " not present in the Trinary tree");
		}
		if (isPresent(root, value)) {
			root = delete(root, value);
		}
		return root;
	}

	// Find the maximum element of the subtree starting from the given "root"
	// node
	// Maximum element is the Right child of the right-most subtree of the given
	// tree node
	private Node findMax(Node root) {
		if (root == null) {
			return root;
		} else {
			while (root.getRight() != null) {
				root = root.getRight();
			}
		}
		// System.out.println("Max element = " + root.getData());
		return root;
	}

	// Method to check if node with the given value is present in the tree or
	// not
	private boolean isPresent(Node root, int value) {
		if (root == null) {
			return false;
		} else if (value == root.getData()) {
			return true;
		} else if (value < root.getData()) {
			return isPresent(root.getLeft(), value);
		} else if (value > root.getData()) {
			return isPresent(root.getRight(), value);
		}
		return false;
	}

	// Inorder Tree Traversal starting from the Root of the Trinary Tree
	public void traverseTree(Node root) {
		if (root != null) {
			traverseTree(root.getLeft());
			traverseTree(root.getCenter());
			System.out.print(root.getData() + " ");
			traverseTree(root.getRight());
		}
	}

	// Method to traverse the Trinary tree
	public void traverseTree() {
		System.out.println("---------------------------------------------");
		System.out.println("Passagem da arvore a partir da raiz : ");
		if (this.root == null) {
			System.out.println("Arvore Vazia");
		} else
			traverseTree(root);
		System.out.println();
		System.out.println("---------------------------------------------");
	}
}
